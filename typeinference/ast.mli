type binop =
	Plus
	| Minus
	| Times
	| Divide
	| Modulo

type boolbinop =
	Equals
	| Less
	| Greater

module VarMap : Map.S with type key = string

type ltype =
	TInt
	| TBool
	| TUnit
	| TString
	| TFunction of ltype * ltype
	| TNamedType of string (* A named type as encountered in application code (e.g., "list") *)
	| TNewType of string (* A primitive type, for example "list/1", generated by ADT typechecker *)
	| Typevar of string * optional_type
	| TypeWithLabel of string * (string * ltype) list
	| TProduct of ltype * ltype
	| TSum of ltype * ltype
	| TRef of ltype
	| TRecord of ltype VarMap.t
	| TForAll of string list * ltype
	| TADT of adt
	| TParameterized of ltype * ltype
	| TModule of module_type_entry list
and adt = adt_cons list
and adt_cons = string * ltype list
and module_type_entry =
	| AbstractType of string * string list
	| ConcreteType of string * ltype
	| Value of string * ltype
and optional_type = ltype option ref

type expr =
	Var of string
	| Abstraction of string * optional_type * typed_expr
	| Application of typed_expr * typed_expr
	| In of in_expr * typed_expr
	| Int of int
	| Bool of bool
	| String of string
	| Binop of binop * typed_expr * typed_expr
	| Boolbinop of boolbinop * typed_expr * typed_expr
	| If of typed_expr * typed_expr * typed_expr
	| Fix of typed_expr
	| Pair of typed_expr * typed_expr
	| Projection of bool * typed_expr
	| RevealType of typed_expr
	| Case of typed_expr * typed_expr * typed_expr
	| Injection of bool * typed_expr
	| Sequence of typed_expr * typed_expr
	| Assignment of typed_expr * typed_expr
	| Dereference of typed_expr
	| Allocation of typed_expr
	| Record of typed_expr VarMap.t
	| Member of typed_expr * string
	| ConstructorMember of typed_expr * string
	| Unit
	| Constructor of string
	| Match of typed_expr * (pattern * typed_expr) list
	| Error of string
	| Wrapped of typed_expr
	| Dummy of value
	| Module of ltype option * in_expr list
and typed_expr = expr * ltype option ref
and pattern =
	PAnything
	| PVariable of string
	| PConstructor of string
	| PApplication of pattern * pattern
	| PInt of int
	| PBool of bool
	| PString of string
	| PPair of pattern * pattern
	| PGuarded of pattern * typed_expr
	| PAs of pattern * string
and value =
	| VInt of int
	| VBool of bool
	| VString of string
	| VUnit
	| VAbstraction of string * value VarMap.t * typed_expr
	| VReference of value ref
	| VRecord of value VarMap.t
	| VConstructor of string
	| VADTInstance of value * value
	| VPair of value * value
	| VInjection of bool * value
	| VError of string
	| VDummy of typed_expr * value VarMap.t
	| VModule of module_type_entry list * value VarMap.t
	| VBuiltin of builtin_function
and in_expr =
	| Let of string * optional_type * typed_expr
	| LetRec of string * optional_type * typed_expr
	| LetADT of string * string list * adt
	| TypeSynonym of string * ltype
	| SingleExpression of typed_expr
	| Open of string
	| Import of string
and builtin_function = value -> value

type kind =
	| KStar
	| KArrow of kind * kind
	| KVar of string * kind option ref

val string_of_type : ltype -> string

val string_of_module_type_entry : module_type_entry -> string

val f_of_binop : binop -> int -> int -> int

val string_of_bool_binop : boolbinop -> string

val f_of_bool_binop : boolbinop -> int -> int -> bool

val string_of_binop : binop -> string

val string_of_expr : expr -> string

val string_of_in_expr : in_expr -> string

val string_of_value : value -> string

val string_of_kind: kind -> string

val new_typevar : unit -> ltype

val new_kindvar : unit -> kind

val next_id : unit -> string

val qualify_name : string -> string

val prune_type : ltype -> ltype
